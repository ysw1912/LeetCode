### 46. Permutations

-----

&emsp;&emsp;给定一个没有重复数字的序列，返回所有全排列。

```text
输入: [1, 2, 3]
输出:
[
  [1, 2, 3],
  [1, 3, 2],
  [2, 1, 3],
  [2, 3, 1],
  [3, 1, 2],
  [3, 2, 1]
]
```

-----

#### 正解一 递归

&emsp;&emsp;从字符串中选择某一字符作为排列的第一个字符，然后对剩余字符串全排列。

#### 正解二

&emsp;&emsp;首先让所有元素升序排序，之后不断求出 next permutation。

&emsp;&emsp;如找 23541 的下一个排列：

1. 从右到左扫描，看哪个数右边的数比它大，找到 3。3 的右边是5，说明 3 可以增大。
2. 3 能增大到多少呢？能增大到它右边比它大的数中最小的那个数。由于 3 的右边一定是降序，从右向左扫描，找到第一个比 3 大的数 4。
3. 那么 23541 的下一个排列是 24xxx，显然 xxx 应该升序排列，于是应该是 24135。
4. 交换 3 和 4 得到 24531。由于之前 3 的右边 541 一定是降序，且 4 是右边开始第一个大于 3 的数，因此交换后的 531 也一定是降序，这样把 531 翻转即为所求。

&emsp;&emsp;全排列总共有 n! 种情况，因此两种复杂度都是 O(n!)。
