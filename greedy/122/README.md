### 122. Best Time to Buy and Sell Stock II

-----

&emsp;&emsp;给定一个数组，第 i 个元素表示第 i 日的股票价格，可以进行任意次交易（买股票—卖股票）。

&emsp;&emsp;例如数组 [7, 1, 5, 3, 6, 4]，可以第 2 天买，第 3 天卖，获益 5 - 1 = 4；第 4 天买，第 5天卖，获益 6 - 3 = 3；总收益 4 + 3 = 7。

&emsp;&emsp;注意，买之前必须确保手上没有股票（卖掉后才能买）。

-----

#### 正解一 O(n)

&emsp;&emsp;本题是个贪心 easy 题，关键在于想清楚怎么样收益才是最大的，就不会往奇怪的地方想，比如搜索或者 DP。

&emsp;&emsp;例如数组 [2, 4, 6, 9] 的最大收益方式是 9 - 2 = 7。如果选择 (4 - 2) + (9 - 6) = 5，其损失的部分来自于第 2 天卖出和第 3 天买入，亏了 6 - 4 = 2。

&emsp;&emsp;因此如果该数组是递增的，则在第 1 天买入，最后 1 天卖出是最佳方法，这也是符合常识的。一个更普遍的例子 [3, (2, 4, 6, 9), 4, (3, 4, 7)]，其中的两个括号表明了数组内两个最长的“递增子数组”，最佳收益即为 (9 - 2) + (7 - 3) = 11。

&emsp;&emsp;找到数组中的多个递增子数组并不难，但该题并不需要这么做。例如数组 [2, 4, 6, 9]，可以将 9 - 2 数学上看成 (9 - 6) + (6 - 4) + (4 - 2)，如果硬要赋予它一个含义，那可以理解为第 2 天卖出 4 并立刻花 4 买入，第 3 天卖出 6 并立刻花 6 买入，因此 +4、-4、+6、-6 就抵消了。因此只需要对于第 i 个元素和第 i + 1 个元素，如果 prices[i + 1] > prices[i]，则加上 prices[i + 1] - prices[i] 即可。

-----

#### 正解二 O(n)

&emsp;&emsp;DP 数组 dp[i]：第 0 ~ i 天的最大收益，每天有两种状态：持有股票和不持有股票。
- dp[i][0]：第 i 天“持有股票”时，所能获得的最大收益；
- dp[i][1]：第 i 天“未持有股票”时，所能获得的最大收益。

初始条件是，如果第 0 天“持有股票”，则收益为 -prices[0]；如果第 0 天“未持有股票”，收益为 0。

递推公式是，
- 如果第 i 天是“持有股票”，则可能是①第 i - 1 天也“持有股票”，第 i 天什么都不做；②第 i - 1 天“未持有股票”，则第 i 天需要买入。
- 如果第 i 天是“未持有股票”，则可能是①第 i - 1 天也“未持有股票”，第 i 天什么都不做；②第 i - 1 天“持有股票”，则第 i 天需要卖出。

最终最大收益的情况肯定是最后一天“未持有股票”，因此直接返回 dp[size - 1][1]。

```cpp
int maxProfit(vector<int>& prices) {
  int size = prices.size();
  if (size < 2) return 0;
  vector<vector<int>> dp(size, vector<int>(2));
  dp[0][0] = -prices[0];
  dp[0][1] = 0;
  for (int i = 1; i < size; i++) {
    dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] - prices[i]);
    dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] + prices[i]);
  }
  return dp[size - 1][1];
}
```
