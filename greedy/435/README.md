### 435. Non-overlapping Intervals

-----

&emsp;&emsp;给定一个区间的集合，找到需要移除区间的最小数量，使剩余区间互不重叠。

-----

#### 正解一 DP

按照起始点对区间进行排序，从起点DP

dp[i]: 到第 i 个区间范围内，最大可能的区间数

dp[i] = max(dp[j]) + 1，其中 j < i 且 i 区间与 j 区间不重叠

最终结果为区间的总数减去 dp 数组中的最大值

-----

#### 正解二 DP

按照终点对区间进行排序，从终点DP

dp[i]: 到第 i 个区间范围内，最大可能的区间数

有两种情况：
- i 区间被包含：从 i 到开头遍历，寻找第一个与 i 不重叠的区间 j，则 dp[i] = d[j] + 1
- i 区间不被包含：dp[i] = d[i - 1]

则 dp[i] = max(d[j] + 1, d[i - 1])

最终结果为区间的总数减去 dp 数组中的最大值

两种 DP 时间复杂度：O(n^2)，空间复杂度：O(n)

-----

#### 正解三 贪心

按起点对区间进行排序。遍历时，用 prev 指针追踪刚刚添加到最终列表中的区间。对于当前的区间 curr，可能遇到三种情况：

- curr 与 prev 不重叠，则将 prev 赋值为 curr，移除区间数量不变。
- curr 与 prev 重叠，curr 终点在 prev 终点之前，则 prev 肯定是包含了 curr，prev 更新为 curr，移除区间数量 + 1。
- curr 与 prev 重叠，curr 终点在 prev 终点之后，则此时移除 curr 总是更好的，prev 不变，移除区间数量 + 1。

-----

#### 正解四 贪心

按终点对区间进行排序。遍历时，用 prev 指针追踪刚刚添加到最终列表中的区间。对于当前的区间 curr，可能遇到两种情况：

- curr 与 prev 不重叠，则将 prev 赋值为 curr，移除区间数量不变。
- curr 与 prev 重叠，则直接移除 curr 区间，prev 不变，移除区间数量 + 1。
