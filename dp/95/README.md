### 95. Unique Binary Search Trees II

-----

&emsp;&emsp;给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。
```text
输入：3
输出：vector<TreeNode*>，包含 5 个元素
对应以下 5 种不同结构的二叉搜索树

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

```

-----

#### 正解一 递归

&emsp;&emsp;对于连续整数序列 [start, end] 中的一点 i，若要生成以 i 为根节点的BST：
- i 左边的序列为左子树结点，且可能有多种情况：```vector<TreeNode*> left_nodes = generate(start, i - 1);```
- i 右边的序列为右子树结点，同上：```vector<TreeNode*> right_nodes = generate(i + 1, right);```
- 产生的以 i 为根结点的 BST 有```left_nodes.size() * right_nodes.size()```个

&emsp;&emsp;最外层循环使得 [start, end] 中每个结点都能生成子树序列

-----

#### 正解二 DP

&emsp;&emsp;将递归用自底向上 DP 的思想重写，数组 dp[i] 表示 i 个连续数字组成 BST 的所有解。

&emsp;&emsp;如 n = 3 时进行 DP
```text
0 个连续数字的所有解
  []

1 个连续数字的所有解
  [ 1 ]
  [ 2 ]
  [ 3 ]

2 个连续数字的所有解
  [ 1 2 ]
  1          2
   \        /
    2      1
  [ 2 3 ]
  2          3
   \        /
    3      2

如果求 3 个数字的所有情况。
[ 1 2 3 ]
利用之前递归的思路，就是分别把每个数字作为根节点，然后考虑左子树和右子树的可能
1 作为根节点，左子树是 [] 的所有可能，右子树是 [ 2 3 ] 的所有可能，利用之前求出的结果进行组合：
      1             1
    /   \         /   \
  null   2      null   3
          \           /
           3         2
    
2 作为根节点，左子树是 [ 1 ] 的所有可能，右子树是 [ 3 ] 的所有可能，利用之前求出的结果进行组合：
     2
   /   \
  1     3

3 作为根节点，左子树是 [ 1 2 ] 的所有可能，右子树是 [] 的所有可能，利用之前求出的结果进行组合。
     3              3
   /   \          /   \
  1   null       2   null
   \            /
    2          1
```

&emsp;&emsp;注意到，求“2 个连续数字的所有解”的时候，我们需要求 [ 1 2 ] 和 [ 2 3 ] 的所有可能，但这只是 n = 3 的情况。

&emsp;&emsp;如果 n = 100，则要求 [ 1 2 ]、[ 2 3 ]、[ 3 4 ] ... [ 99 100 ] 的所有可能。能否进行优化？

&emsp;&emsp;观察发现，“2 个连续数字的所有解”其实只有两种结构，只是数字不一样罢了。
```text
  x          y
   \        /
    y      x
```

&emsp;&emsp;所以 n = 100 时，求“2 个连续数字的所有解”的时候，我们没必要把 [ 1 2 ]、[ 2 3 ]、[ 3 4 ] ... [ 99 100 ] 所有的情况都求出来，只需要求出 [ 1 2 ] 的所有情况即可。

&emsp;&emsp;推广到任意长度 len，其实只需要求 [ 1 2 ... len ] 的所有情况就可以了。

&emsp;&emsp;但 [ 2 3 ] ， [ 3 4 ] ... [ 99 100 ] 这些怎么办呢？

&emsp;&emsp;举个例子，n = 100，此时我们求把 98 作为根节点的所有情况，需要长度是 97 的 [ 1 2 ... 97 ] 的所有情况作为左子树，长度是 2 的 [ 99 100 ] 的所有情况作为右子树。

&emsp;&emsp;[ 1 2 ... 97 ] 的所有情况是 [ 1 2 ... len ] ，能够求出来。

&emsp;&emsp;但 [ 99 100 ] 怎么办呢？只需要在 [ 1 2 ] 的所有情况中，每个数字加一个偏差 98，即加上根节点的值就可以了。

&emsp;&emsp;因此需要一个函数，实现树的复制并且加上偏差。

```cpp
TreeNode* clone(TreeNode* root, int offset) {
  if (!root) {
    return nullptr;
  }
  return new TreeNode(root->val + offset, clone(root->left, offset), clone(root->right, offset));
}
```

