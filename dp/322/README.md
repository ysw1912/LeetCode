### 322. Coin Change

-----

&emsp;&emsp;给定不同面额的硬币 coins 和一个总金额 amount。

&emsp;&emsp;计算可以凑成总金额的最少硬币数。如果没有任何一种组合能组成总金额，返回 -1。

&emsp;&emsp;每种硬币的数量是无限的。

-----

#### 正解一 自上到下DP 时间O(amount * n) 空间O(amount)

&emsp;&emsp;定义函数 DP(amount)：组成金额 amount 所需的最少硬币数量。

&emsp;&emsp;对于每个硬币面值 coin，有 DP(amount) = DP(amount - coin) + 1，需要枚举每个硬币面值并选择最小值。

&emsp;&emsp;为避免重复计算，将中间结果缓存。

#### 正解二 DP 时间O(amount * n) 空间O(1)

&emsp;&emsp;状态转移方程中 i 只与 i - 1 有关，可降维。

#### 正解三 DFS + 剪枝

- 贪心
  
  想要总硬币数最少，肯定是优先用大面值硬币，所以对 coins 按从大到小排序。
  
  先尽量选择大硬币，再选会超过总额时，就可以 DFS 下一层选择稍小面值的硬币。
  
  乘法计算最多能选择 k = amount / coins[idx] 个面值为 coins[idx] 的硬币，则当前选择了 current + k 个硬币，剩余要凑 amount - k * coins[idx] 元。

  如果因为选多了导致最后无法凑出总额，再继续减少大硬币数量 k, k - 1, ..., 0。

- 最先找到的不一定是最优解

  以 coins = [1, 7, 10], amount = 14 为例，
  
  按照贪心思路 10 + 1 + 1 + 1 + 1 会比 7 + 7 更早找到，所以还是要把所有情况都递归完。

- 剪枝

  以 coins = [2, 3, 5], amount = 11 为例，
  
  得到 [5, 3, 3] 这个局部最优（3枚硬币）后，虽然存在一个可能解 [3, 3, 3, 2]，但当选择了 11 / 3 = 3 枚面值为 3 的硬币后，由于此时选择的硬币书已经等于先前得到的最优结果 3，于是会提前停止。
  
  当 amount 较大，特别是 coins[] 元素方差很大的情况下，这个剪枝非常高效。
